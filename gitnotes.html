<html>
<head>
<title>consttype.org - git notes</title>
<link rel="stylesheet" type="text/css" href="consttype.css" />
</head>
<body>
<h1>Git notes</h1>
<h3>How remotes work</h3>
One of the difficult things for a git beginner to understand is how remote branches work.
Basically, as git is a distributed version control system, every developer has a full and independent repository. So, how can you pass changes around?
<p />
In the examples below, we'll consider a basic case: one remote repository, that we'll call <i>origin</i>, and a local one (that we'll call <i>local</i>). The remote repository has one branch, called <i>master</i>, that has been cloned as <i>origin/master</i> on the local repository. Moreover, the local repository has one local branch, called <i>master</i> as well (but it doesn't need to be), which is set up to track changes that happen on <i>origin/master</i>. Note that, as <i>origin/master</i> is a remote branch, it cannot be checked out -- only <i>master</i> can.
<p />
The fetch operation (command <tt>git fetch</tt>) copies the latest commits from the master on <i>origin</i> to <i>origin/master</i>, and updates the HEAD of the <i>origin/master</i> branch:
<p />
<tt>git fetch origin</tt>
<p /><img src="img/git/git-fetch-ff.png" />
<p />The circles on the schema represent commits, and the arrows are the parent-&gt;child relationship between commits. The labels indicate the various HEADs (or branches). It is to be noted that a branch is nothing more than a label following the HEAD of a series of commits.
<p />
At the end of this operation, <i>origin/master</i> matches the <i>master</i> branch on the <i>origin</i>, but <i>master</i> on the local repository is still behind. We need to use the <tt>git merge</tt> command to make <i>master</i> point at the same commit than <i>origin/master</i>:
<p />
<tt>git merge origin/master</tt>
<p /><img src="img/git/git-merge-ff.png" />
<p />This kind of merge is called a <i>fast-forward</i> because no actual merging of changes is involved. No new commit is created; we have just moved a HEAD forward in history. And that's fast.
<p />
Now, what happens if you committed a change on your master on <i>local</i>? Nothing changes for the fetch; the two new commits are still created from origin's master so <i>origin/master</i> matches it exactly:
<p />
<tt>git fetch origin</tt>
<p /><img src="img/git/git-fetch-lc.png" />
<p />However, on <i>local</i>, <i>master</i> and <i>origin/master</i> have bifurcated. To reunite them, you'll need to use <tt>git merge</tt>, that will create another commit, and make <i>master</i> point to it:
<p />
<tt>git merge origin/master</tt>
<p /><img src="img/git/git-merge-lc.png" />
<p />The new commit (in orange) is a merge commit: it has two parents. (If conflicts happens, git will ask you to resolve them.)
<p />
Ah, but now, your master has two more commits that the origin's master. And you surely want to share your changes with your fellow developers. That's where the git push command is useful:
<p />
<tt>git push origin</tt>
<p /><img src="img/git/git-push-lc.png" />
<p /><tt>git push</tt> will start by copying your two commits to the origin, and ask it to update its master to point at the same location than yours. At the end of the operation, both commit trees should match exactly. Note that <tt>git push</tt> will (in the default configuration) refuse to push if your origin/master is not up to date.
<p />The "origin" argument to <tt>git fetch</tt> and <tt>git push</tt> is optional; git will use all remotes if you don't specify one.
<p />Finally, a note: as fetch and merge are often done together, a git command combines both: <tt>git pull</tt>. It's smarter than the addition of the two commands, because it knows how to look in your git config what remote branch is actually tracked by your current local branch, and merge from there -- so you don't even need to type the name of <i>origin/master</i> for the merge.
<h3>On rebasing</h3>
We've seen how git manages to merge your local changes when you pull from a remote repository.
<p />
This approach has a small downside, aesthetically: that is, the creation of a large number of merge commits, making the history more difficult to read. Wouldn't it be nice if git offered you the possibility to simply re-apply your local changes on top of what you just pulled?
<p />
Rejoice, because that's what the <tt>git rebase</tt> command is for.
<p />
<tt>git rebase origin/master</tt> will take the local commits (that are reachable from the <i>master</i> head, but not from <i>origin/master</i>), remove them from the commit tree, and re-apply them on top of <i>origin/master</i>, before moving the master head to the top of the new line of commits it just created. That way, the history is kept linear:
<p />
<img src="img/git/git-rebase-lc.png" />
<p />
You can afterwards just push your new commits.
<p />
Important warning: <tt>git rebase</tt> changes your commits. Because their place in the tree will be different, their SHA1 will be different as well; and the old ones will disappear. For that reason, you must not manipulate commits with rebase if you have already published them in a shared repository from which someone else might have fetched.
<p />
Rebasing is a powerful tool that will enable you to manipulate your branches, moving lines of commits from one location to another. The git-rebase man page has more examples.
<hr />
<small><a href="/">Back to consttype</a></small>
</body>
</html>
